---
layout: post
title:  "객체지향 디자인의 5원칙(SOLID 원칙)"
date:   2019-01-14 06:30:00 +0900
categories: etc
comments: true
---

## 들어가는 글
나는 웹개발 백엔드 쪽을 담당하고 있는데 작년 2018년 중반쯤에 내가 맡은 프로젝트의 요구사항이 상당히 자주 바뀌어서 고생을 했던적이 있다.

그 프로젝트 이후 요구사항이 자주 바뀌어도 빠르게 대처할 수 있는 방법이 필요했고

객체지향의 개념, 객체지향 디자인의 5대 원칙, 디자인 패턴등의 존재를 알게 되어 디자인 패턴을 공부하기 전 객체지향의 개념과 객체지향 5대원칙을 공부했다.

객체지향의 개념과 객체지향 디자인의 5대 원칙을 공부한 후엔 객체지향의 강력함을 몸소 깨달았다.

그도 그럴것이 이전엔 요구사항이 바뀌면 프로젝트 이곳저곳을 돌아다니며 내 코드를 수정해야 했었는데  
단순히 SRP(단일 책임 원칙)와 OCP(개방-폐쇄 원칙)를 지키는 것만으로 작업시간이 대폭 줄어든 것을 몸소 체감했으니 말이다!

이번 글은 내 작업시간을 대폭 줄여준 객체지향 디자인의 5원칙이 무엇인지, 왜 지켜야 하는 것인지를 알아보도록 하겠다.

* * *

## 객체지향 디자인의 5원칙(SOLID)이란?

객체지향 디자인의 5대원칙이란 유연한 객체지향 애플리케이션을 만들기 위해 따라야 하는 5가지 원칙을 말한다. 다섯가지 원칙은 다음의 다섯가지이다.

* SRP(Single Responsibility Principle)단일 책임원칙
* OCP(Open Closed Principle) 개방 - 폐쇄 원칙
* LSP(Liskov substitusion Principle) 리스코프 치환 법칙
* ISP(Interface Segregation Principle) 인터페이스 분리 원칙
* DIP(Dependency Inversion Principle) 의존성 역전 법칙

앞글자를 따서 SOLID라고 부르기도한다.

그럼 이 다섯가지 원칙은 무엇이고 왜 사용해아 하는 것일까?

* * *

## 뭐 때문에 있는 원칙이지?

필자는 개인적으로 무언가를 배울 때는 그것이 무엇때문에 나오게 됬는지(무슨 문제를 해결하기 위해 나왔는지)부터 알아야 이해가 쉽다고 생각한다.

이 5원칙은 나쁜 객체지향 디자인을 지양하기 위해 만들어진 원칙인데 객체지향의 나쁜 디자인은 무엇을 말하는 걸까?

사람마다 나쁜 객체지향 디자인에 대한 기준점은 조금씩 다르지만 거의 모든 프로그래머들이 동의하는 나쁜 디자인에 대한 기준은 다음과 같다.

1. 모든 변경마다 많은 다른 부분에 영향을 미쳐 변경 자체가 어렵다.
2. 변경 작업을 할때 예상치 못한 다른 부분이 망가진다.
3. 현재의 어플리케이션에서 분리할 수 없기 때문에 다른 어플리케이션에서 재사용 하기가 매우 어렵다.

이러한 문제들을 해결하기 위해 객체지향 디자인의 5원칙이 나오게 된것이다.

이제 객체지향 디자인의 5원칙으로 해결하고자 하는 문제를 머릿속에 각인 시켜두고 5원칙에 대해 알아보자.

## SRP 단일 책임 원칙

**모든 클래스는 단 하나의 책임을 가져야 한다.**  
이는 곧 **클래스를 수정할 이유는 오직 하나**여야 한다는 뜻이기도 하다.  

클래스를 고치는 것은 최대한 피해야 한다. 코드를 변경하다보면 온갖 문제가 생겨날 수 있기 때문이다. 코드를 변경할 이유가 두가지 이상이 된다면 그만큼 그 클래스를 나중에 고쳐야 할 가능성이 커지게 될 뿐 아니라, 디자인에 있어서 두 가지 부분에 동시에 영향이 미치게 된다.

예를 들어, 게임 프로그램의 CharacterAndEvent 클래스를 만들었다. 그 클래스로 만들어진 객체가 **게임 내 이벤트 배너를 표시하는 책임**, **캐릭터의 상태를 표시하는 책임** 등의 두가지 이상의 책임을 가지고 있다면, Character 클래스로 만들어진 객체에 의존하는 객체들은 두 가지 이상의 책임에 관련된 변화에 모두 영향을 받을 수 있어 요구 사항 변화에 대한 유연성이 좋지 않다.


##  OCP 개방 - 폐쇄 원칙

**클래스는 확장에 대해서는 개방 되어 있어야 하지만, 수정에 대해서는 폐쇄 되어야 한다.**

처음엔 확장에 대해서는 열려 있고 코드 변경에 대해서는 닫혀 있다는게 모순되어 보이고 이해가 되지 않을 수 있다. OCP 원칙은 직접 코드를 **수정**해서 확장하는것이 아닌 코드를 수정하지 않고도 기능을 **확장**할 수 있게 설계하는 것이 핵심이다.

앞에서 언급하진 않았지만 디자인 패턴 중 옵저버 패턴 을 이용하여 코드를 수정하지 않고도 기능을 확장하는 예를 들어보자.
[옵저버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)

옵저버 패턴은 Subject 인터페이스를 구현한 클래스의 코드를 변경하지 않고 실행 중 Observer의 추가와 삭제가 가능하다. 이것이 코드를 수정하지 않으면서도 기능을 확장할 수 있게 하는 설계의 예라고 할수 있다.

##  LSP 리스코프 치환 법칙

**서브타입은 언제나 자신이 기반타입 (base type)으로 교체할 수 있어야 한다.**

자식 클래스는의 객체는 언제나 자신의 부모클래스타입의 변수로 참조할 수 있어야 한다는 원칙이다. 즉 부모클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것.

다시말해, 자식클래스 타입의 객체를 부모클래스의 참조변수로 참조하여 사용해도 아무런 문제가 없어야 한다는 것이다.

도형을 예로 들어보자. Shape(도형) 클래스와 Rectangle(사각형) 클래스가 있고, Rectangle 클래스는 Shape 클래스의 상속을 받는다.

도형의 특징은 다음과 같다.

>1 도형은 둘레를 가지고 있다.
>2 도형은 넓이를 가지고 있다.
>3 도형은 각을 가지고 있다.


위 특징의 도형이란 단어 대신 사각형을 대입해봐서 Rectangle 이 Shape 의 일반화 관계인지 확인해보자.

>1 사각형은 둘레를 가지고 있다.
>2 사각형은 넓이를 가지고 있다.
>3 사각형은 각을 가지고 있다.

1 ~ 3 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형은 사각형을 일반화 했다고 볼 수 있다.

여기서 원(Circle)을 생각해보자. Circle 클래스 역시 Shape 클래스의 상속을 받는다. 원 역시 도형의 특징에서 도형이란 단어 대신 원을 대입해보자.
>1 원은 둘레를 가지고 있다.
>2 원은 넓이를 가지고 있다.
>3 원은 각을 가지고 있다.

문장을 읽어보면 3번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않은 설계라 할 수 있다. 따라서 도형클래스는 3문장에 대해서 일반화 관계가 성립하도록 수정되어야 한다.

더 자세한 정보는 아래 링크를 참조하자
[리스코프 치환원칙](http://vandbt.tistory.com/41)


## ISP 인터페이스 분리 원칙

**클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다고 한다.**

먼저 의존관계란 **한 클래스가 다른 클래스에서 제공하는 기능을 사용할때를 나타내는 관계**를 말한다.
예를들어 **A클래스는 B클래스에 의존한다.** 이 말은 A클래스가 B클래스에서 제공하는 기능을 사용하는 것을 나타낸다.
쉽게 말하자면 단순히 A클래스 안의 메소드에서 B클래스의 기능을 이용한다면 **A클래스는 B클래스에 의존한다.** 라고 할 수 있는것이다.

다시말해, 어떤 클래스가 다른 클래스의 기능을 사용할 때에는 가능한 최소한의 인터페이스만을 사용해야 한다.

예를 들어보자

게시판 게시물 조작의 책임을 가진 객체가 있다. 이 객체를 사용하는 클라이언트는 게시판 이용자, 글을 쓴 본인, 관리자 등이 있을 것이다.

글을 쓴 본인도 아니고 관리자도 아닌 게시판 이용자는 글을 삭제, 수정할 권한이 없다. 그러므로 수정 삭제에 대한 인터페이스를 제공하지 않는다.

글을 쓴 본인은 글을 삭제, 수정할 권한이 있다. 그러므로 수정 삭제에 대한 인터페이스를 제공한다.

관리자는 글을 삭제, 수정 또한 추천글 등으로 올릴 권한을 가지고 있다. 그러므로 수정 삭제에 대한 인터페이스는 물론 추천글로 올리는 인터페이스까지 제공한다.

이렇게 인터페이스를 분리하여 클라이언트는 자신이 사용하지도 않는 메서드들이 가득 담긴 비대한 인터페이스를 받을 일이 없다. 혹은 애초에 사용하지 않는 인터페이스를 구현하지 않을 수도 있다. SRP가 클래스의 단일책임을 강조한다면 ISP는 인터페이스의 단일책임을 강조하는 것이다.

##DIP 의존성역전의 원칙

**추상화 된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.**


왜 추상화된 클래스는 구체적인 클래스에 의존하면 안되고 구체적인 클래스가 추상화된 클래스에 의존해야 하는 것일까?

실세계의 어린아이를 클래스로 추상화하여 예를 들어보자

아래의 코드는 어린이가 자신이 무슨 장난감을 가지고 노는지 출력하는 코드이다.

![장난감 다이어그램](../img/kidDiagram.png)

```
public class Kid{
	private Robot robot = new Robot();

    public void play(){
    	System.out.println("i'm playing with " + robot.getName() + "!");
    }
}

public class Robot extends Toy{
	private String name = "robot";

    public void getName(){
    	return name;
    }
}

public class Main{
	public static void main(char[] args){
    	Kid kid = new Kid();
        kid.play();
    }
}


```
```
i'm playing with robot!
```

Toy추상클래스, MiniCar구상클래스, Lego 구상클래스는 있다고 가정하자

위 코드의 문제점은 무엇일까 Kid클래스가 Toy 추상클래스가 아닌 Robot 구상클래스에 의존하고 있다. 이로인해 어린이가 다른 장난감을 가지고 놀려면 Kid클래스의 private Robot robot = new Robot(); 부분을 수정해야한다. DIP의 위배가 OCP위배까지 불러온 것이다.

위의 코드를 DIP원칙을 이용하여 수정해보자

```
public class Kid{
	private Toy toy;

    public Kid(Toy toy){
    	this.toy = toy;
    }

    public void setToy(Toy toy){
    	this.toy = toy;
    }

    public void play(){
    	System.out.println("i'm playing with " + toy.getName() + "!");
    }
}

public class Robot extends Toy{
	private String name = "robot";

    public void getName(){
    	return name;
    }
}

public class MiniCar extends Toy{
	private String name = "miniCar";

    public void getName(){
    	return name;
    }
}

public class Main{
	public static void main(char[] args){
    	Kid kid = new Kid(new Robot());
        kid.play();
        kid.setToy(new MiniCar());
        kid.play();
    }
}


```
```
i'm playing with robot!
i'm playing with miniCar!
```

이제 Kid클래스는 Robot 구상클래스가아닌 Toy 추상클래스타입에 의존한다. 그로인해 자연스럽게 장난감을 변경하려면 Kid클래스의 코드를 변경해야 했던 이전코드에 반해 실행중 기능을 변경할 수 있는 유연한 코드가 탄생했다. 또한 새로운 장난감이 생긴다고해도 Toy클래스와 다른 기존클래스들은 변경하지 않고 새로운 장난감 클래스를 추가해 기능을 확장할 수 있게 되었다.

다시말해 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스 타입을 참조하여, 구상 클래스들의 변화에 영향받지 않게 하는 것이 의존역전 원칙의 핵심이다.


* * *

## 마무리

어쩌다보니 마지막 DIP 의존성역전 원칙만 열심히 설명한것 같은 기분이 들지만 객체지향을 복습하게되어 기본이 더 탄탄해진 기분이다.

또 객체지향 관련 글을 3개 작성하고 1년전에 내가 짯던 코드를 수정하고있으니 매우 부끄러워지는 현상을 경험했다. 성장하고 있다는 좋은 신호로 받아들여야겠다.
