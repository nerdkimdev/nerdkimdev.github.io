---
layout: post
title:  "객체지향의 4가지 특징"
date:   2019-01-10 06:30:00 +0900
categories: etc
comments: true
---

## 들어가는 글

나는 지금 다니고 있는 회사가 첫 회사인데, 입사할 때 기술면접을 보지않아 기술면접의 경험이 없다. 애초에 신입에게 실력에 대한 기대보단 배우려고 하는 의지, 인성을 중점적으로 보신것 같다.

이전 포스트에서 말했던것처럼 2018년 중반에 요구사항변경의 수난을 겪고, 혼자 객체지향을 공부하던 중 기술면접 단골질문 이라는 글을 보았다. 그 글에 적힌 첫번째 단골질문은 "추상화가 뭔지 저에게 설명 해주실 수 있나요?" 였고, 나는 말문이 막혔다. 대강 코드상으로는 어떻게 적용하는지는 알고 있었으나 말로하려니 한마디도 나오지 않았다. 곧 군대를 가야하기에 5년안에 이직은 필연적인데 첫번째 질문부터 말문이 막혔다.

이것이 이번 글을 쓰게 된 이유다. 내가 알고 있는 추상화, 캡슐화, 상속성, 다형성 을 글로 정리하면 이후의 기술면접에서 술술 나오지 않을까 하는 막연한 기대감으로 이번 글을 작성하려고 한다.


[객체지향 프로그래밍의 특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)
[객체지향 특징 4가지](http://richong.tistory.com/122)

* * *

## 목표


> 객체지향 프로그래밍의 4가지 특징을 이해한다.


* * *

## 추상화(Abstraction)

##### 국어로써의 추상화란 무슨뜻일까?

* **여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용.**
* **개별의 사물이나 표상(表象)의 공통된 속성이나 관계 따위를 뽑아냄**

더해서 추상이란 단어의 한자까지 해석보자면

* **抽: 뺄 추**
* **象: 형상 상**

'형상을 뽑아내는 것', '법칙을 뽑아내는 것', '본떠서 뽑아내는 것' 등으로 마지막에 化(될 화)까지 추가하여 '형상을 뽑아내어 변화시키는 것'이라고 할 수 있다.

또 내 나름대로는 **"중요하다고 생각하는 특성이나 속성 따위를 추출하여 변화시키는 것"** 로 이해했다.

이렇게만 들으면 이해하기가 쉽지 않다. 지도를 예를 들어보자.

지도는 그 목적에 따라 이름과 용도가 달라진다.  

취락,도로,각종 기관,삼림,경지 등이 표시된 것은 지형도(일반도)  
날씨 상태, 기압, 바람의방향 등이 표시된 일기도
표면에 드러난 암석의 분포나 지질의 구조를 색채로 표시한 지질도

위 세가지는 지도를 보는 사람이 현실의 공간으로부터 얻고자 하는 정보에 따라 현실의 공간을 추상화한 결과물이라고 볼 수 있다.

내가 생각한 추상화의 정의에 대입해 보면,

* 지형도
특정 현실공간의 도로, 각종 기관, 삼림, 경지 등의 정보(중요하다고 생각하는 특성이나 속성)를 알기 위해 여러가지 기호들로 표시(추출)하여 평면위에 나타낸(변화) 것

* 일기도
특정 현실공간에서 날씨 상태, 기압, 바람의 반향등의 정보를 알기 위해 여러가지 기호들로 표시하여 평면위에 나타낸 것

*  지질도
특정 현실공간의 표면에 드러난 암석의 분포나 지질의 구조를 색채로 표시하여 평면위에 나타낸 것

같은 대상(특정 현실공간)이라도 추상화하는 기준에 따라 추상화한 결과물에서 얻을 수 있는 정보는 모두 다른 것을 알 수 있다.

마지막으로 쉽게 정리하자면 불필요한 정보를 제거하고 핵심을 추려서 표현하는 방법이라고 할 수도 있다.

#####그렇다면 프로그래밍에서의 추상화란 무엇일까?

프로그래밍에서의 추상화도 현실의 추상화와 크게 다르지 않다.

대표적으로 자료 추상화, 제어 추상화가 있다.

#####자료추상화

자료 추상화의 예는 다음과 같다.

* 변수
data값을 저장하는 메모리위치를 추상화한 것

* 데이터 타입
메모리에 저장될 값들의 종류를 추상화한 것

* 배열
같은 타입의 연속된 변수들의 모음을 추상화한 것

* 레코드(구조체)
다른 타입의 연속된 변수들의 모음을 추상화한 것

간단하게 변수의 예만 들고 제어 추상화로 넘어가자.

다음은 변수 a의 값을 출력하는 코드이다.

```
int a = 1;
printf("%d", a);
```

프로그래머는 a의 값을 출력할 때 1이 저장된 메모리의 주소를 몰라도 된다. 단지 1이 저장된 메모리 위치가 추상화된 a라는 변수를 이용하여 값을 가져오면 될 뿐이다.

#####제어 추상화

제어 추상화 예는 다음과 같다.

* 반복문
반복되는 기계어 명령을 추상화한 것

* 조건문
분기되는 기계어 명령을 추상화한 것

* 프로시저(함수)
명령어군을 특정 이름으로 추상화한 것

이번에는 프로시저와 반복문의 예를 들어보자.

다음 코드는 NerdKim을 사각형 안에 내이름을 100번 출력하는 코드다.

```
printf("************");
printf("*   Nerd   *");
printf("*    Kim   *");
printf("************");
printf("************");
printf("*   Nerd   *");
printf("*    Kim   *");
printf("************");
...
...
printf("************");
printf("*   Nerd   *");
printf("*    Kim   *");
printf("************");
```

중간을 생략하지 않았다면 위의 코드는 400줄의 코드가 될것이다.

제어 추상화의 산물로 이 코드를 열줄 이내로 만들어보자.

```
function printNerdKimBox(){
	printf("************");
    printf("*   Nerd   *");
    printf("*    Kim   *");
    printf("************");
}
for( i = 0; i < 100; i++ ){
	printNerdKimBox();
}
```

사각형을 출력하는 명령어군을 printNerdKimBox란 이름의 함수로 추상화 하고 100번의 반복을 반복문으로 추상화한 결과 이전과 같은 작업을 하지만 훨씬 간결해진 모습을 볼 수 있다.

#####추상 자료형

**추상 자료형**이란 자료 추상화와 제어추상화를 통합해서 추상화한 것이다.

더 자세히 설명하자면 추상 자료형이 포함할 데이터의들의 형태와 그 데이터들에 대한 명령어군들로 추상화하여 새 자료형을 정의한 것이다. C++나 Java에선 class라는 개념이 추상 데이터 타입을 나타낸다.

예를 들어보자

```
class main{
	public static void main(char[] args){
    	Car audi_I8 = new Car("audi_I8");
        audi_I8.fillOil(123);
    }
}

class Car{
	String carName;
    int oilAmount;

    public Car(String carName, int horsePower){
    	this.carName = carName;
        this.horsePower = horsePower;
        this.oilAmount = 0;
    }

    public void drive(){
    	if(oilAmount == 0){
        	System.out.println("no oil remain");
        }
    	System.out.println("i'm driving" + this.carName + "!!");
    }

    public void fillOil(int oilAmount){
    	this.oilAmount += oilAmount;
    	System.out.println("my oilAmount is " + this.oilAmount);
    }
}
```

나는 내 상상속의 차를 Car추상 자료형으로 추상화 했다. 이 프로그램의 목적은 뚜벅이인 내가 상상속의 드림카로 운전하는 것이다. 이 프로그램 안에서의 자동차는 차체의 재질, 시트의 재질, 에어컨의 유무, 내장 네비게이션의 기종 등등에 대한 정보는 없다. 단지 추상 자료형에 정의한 대로 차의 이름, 기름의 양과 그 데이터들로 할 연산들이 있을 뿐이다.

C++와 Java에서는 class의 상속이 가능한데 이를 이용하여 기존의 구상 클래스를 추상화 할 수도 있다.

예를 들어 Teacher 란 클래스와 Student 란 클래스가 있고 둘의 메소드와 변수가 공통된 것이 있다면 이 둘에 대한 상위 클래스로 추상화(일반화)가 가능하다.

Teacher 클래스와 Student 클래스는 둘 다 사람으로 말을 하는 speak()라는 메소드와 이름을 저장하는 name이라는 변수를 공통으로 가지고있다면 다음과 같이 추상화할 수 있다.

```
class Person{
	String name;

    public void speak(String whatToSay){
    	System.out.println("name : " + whatToSay);
    }
}
```

구글에 객체지향의 추상화를 검색하면 대부분 바로 위의 내용만 다루고 있는데 개인적인 욕심으로 자료추상화와 제어추상화까지 설명했다.


* * *

## 캡슐화

이전 글 [객체지향이란 무엇인가](https://nerdkimdev.github.io/etc/2019/01/09/etc-oop.html) 에서 나온 객체의 자율성에 대해 기억하는가? 객체는 자신의 책임을 수행할 때 자기 스스로의 원칙에 따라 어떤 일을 하거나 자기 스스로를 통제하여 절제해야 객체끼리의 결합도를 낮게 유지할 수 있다.

캡슐화가 바로 이 객체의 자율성을 유지하는 방법이다.

캡슐화의 정의는 다음과 같다.

**객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.**

실제 구현 내용 일부를 외부에 감추어 은닉한다. 은닉하는 대상은 외부에서 접근할 시 객체의 자율성에 해를 끼치는 메소드나 객체의 상태등이 있다.

캡슐화의 목적은 다음과 같다.

* 객체의 사용자는 객체의 세부적인 내용을 몰라도 사용가능하게 함.
* 데이터가 변경되는 곳을 객체 내부로 한정함.
* 객체의 자율성을 유지함.

객체를 잘 캡슐화 하려면 객체의 내부와 외부를 명확하게 구분하여. 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단하고, 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통해야 한다. 또 이 객체가 ‘무엇(what)을 수행하는지는 알 수 있지만 ‘어떻게(how)’ 수행하는지에 대해서는 외부의 객체가 알 수 없게 해야 한다.

위의 내용을 지키면 캡슐화의 목적은 자연스럽게 달성된다. 객체의 사용자는 허용된 수단만을 통해서 객체와 의사소통 하기 때문에 객체의 세부적인 내용을 몰라도 객체를 사용할 수 있고, 객체의 데이터를 외부에서 접근하지 못하기 때문에 객체의 데이터가 변경되는 곳이 객체 내부로 한정된다. 그리고 외부의 간섭이 없으니 자연스럽게 객체의 자율성도 유지된다.

덤으로 잘 변경되지 않는 것만을 의사소통 수단으로 제공하면, 변경 시 다른 객체가 영향을 받을 확률도 적어진다.

* * *

## 상속

상속은 부모 클래스로부터 속성과 동작을 상속받을 수 있는 기능이다.

사용 예를 들어보자

한 초보 프로그래머가 격투게임을 구현하려고 한다. 초보 프로그래머는 격투게임에 필수적인 여러가지 캐릭터의 클래스를 정의할 것이다.

```
class KungfuMan
{
    hp
    power
    speed
    walk()
    guard()
    kungfuKick()
    ...
}

class BoxingMan
{
    hp
    power
    speed
    walk()
    guard()
    jab()
    ...
}

...
...

```

위의 코드에는 두가지 캐릭터밖에없지만 50개정도의 캐릭터가 있다고 가정하자 그런데 갑자기 기획자에게서 이런 요청이 들어왔다.

**"철권이라는 격투게임에서는 체력이 낮으면 분노상태가 되서 필살기를 쓸 수 있던데 저희도 그런 기능을 넣는건 어떨까요?"**

큰일났다. 이 불행한 프로그래머는 이제 50개의 캐릭터 클래스를 돌아다니며 분노 상태를 만들어야한다.

50개의 클래스를 돌아다니며 엄청난 노가다로 분노상태를 추가한 후에야 프로그래머는 상속기능이 있단걸 깨달았다.

처음부터 상속을 이용했다면 이런 일은 일어나지 않았을텐데 라며 자책하고 다음처럼 코드를 수정했다.


```
class Character{
	hp
    power
    speed
	rage
    walk()
    guard()
}

class KungfuMan
{
    kungfuKick()
    ...
}

class BoxingMan
{
    jab()
    ...
}

```

50개의 캐릭터들이 가지는 공통적인 상태와 기능을 뽑아 Character 클래스로 일반화했다. 앞으로 공통적인 기능의 변경사항이 있다면 50개의 캐릭터들의 클래스를 돌아다니며 수정할 필요 없이 Character 클래스만 수정하면 된다.

또한 부모 클래스 타입의 참조변수는 자식 클래스의 객체를 참조할 수 있다.

사용 예를 들어보자

```
public class Main {
  public static void main(String[] args) {
    Character character = new BoxingMan();
  }
}
```

이는 설계적으로 큰 이점으로 작용할 수 있다.

* * *

## 다형성

아래 코드는 동물의 울음소리를 출력하는 코드다.
```
public class Cat{
  public void meow(){ System.out.println("meow"); }
}
public class Dog{
  public void bark(){ System.out.println("bark bark"); }
}
public class Parrot{
  public void sing(){ System.out.println("Hello!"); }
}
public class Main {
  public static void main(String[] args) {
    Cat cat = new Cat();
    Dog dog = new Dog();
    Parrot parrot = new Parrot();
    // 동물 세 마리의 울음소리 호출
    cat.meow(); dog.bark(); parrot.sing();
  }
}
```

만약 이 코드에서 출력할 동물의 울음소리가 100가지가 넘는다면? 당신은 100가지의 동물들의 클래스를 이용하여 객체를 생성하고 각각의 울음소리를 내는 메소드를 사용해야 할 것이다.

위 코드를 개선하기 위해 상속과 연계된 다형성을 이용해보자.

**다형성**이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.

세가지 동물들을 Animal이라는 추상클래스를 상속하여 100가지 동물의 종류가 생겨도 끄떡없는 코드를 만들어보자

```
//부모 클래스
public abstract class Animal {
  public abstract void talk();
}

public class Cat{
  public void talk(){ System.out.println("meow"); }
}
public class Dog{
  public void talk(){ System.out.println("bark bark"); }
}
public class Parrot{
  public void talk(){ System.out.println("Hello!"); }
}
public class Main {
  public static void main(String[] args) {
    Pet[] pets = { new Cat(), new Dog(), new Parrot() };

    for (int i = 0; i < 3; i++){
      // 실제 참조하는 객체에 따라 talk 메소드가 실행된다.
      pets[i].talk();
    }
  }
}
```

동물클래스들이 talk라는 메소드를 가진 추상클래스 Animal 을 상속하였고 그 결과 main 메소드에선 실제 참조하는 객체가 무엇인지 몰라도 talk라는 메소드를 사용하여 각각의 메소드를 실행할 수 있게 되었다.

이 외에도 오버로딩(overloading)과 오버라이딩(overriding)이 다형성의 예라고 할 수 있다.
[생활코딩 다형성](https://opentutorials.org/module/516/6127)

* * *

## 마무리

추상화라는 개념이 생각보다 너무 철학적이라고 해야할까 이해하기가 힘들었다. 처음 보는 사람도 이해할 수 있는 뜬구름잡는 글이 아닌 이해하기 쉬운 글을 쓰고싶은데 제대로 전달이 됬을지 모르겠다.

다음 글에서는 객체지향 디자인의 5원칙인 SOLID(SRP, OCP, LSP, ISP, DEIP)에 대해 정리하려 한다.
